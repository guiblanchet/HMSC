% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/corRandomEff.R
\name{corRandomEff}
\alias{corRandomEff}
\title{Species by species  covariance (or correlation) matrix from the parameters of the latent variables (\code{paramLatent})}
\usage{
corRandomEff(hmsc, cor = TRUE, latentToUse = NULL, latentAutoToUse = NULL,
  burning = FALSE)
}
\arguments{
\item{hmsc}{Object of class hmsc.}

\item{cor}{Logical. Whether correlation (\code{TRUE}) or covariance (\code{FALSE}) matrices should be constructed. Default is \code{TRUE}.}

\item{latentToUse}{A vector of integer defining which set of parameters of the estimated non-autocorrelated latent variables should be considered when constructing the correlation matrix. Default uses all the estimated parameters.}

\item{latentAutoToUse}{A vector of integer defining which set of parameters of the estimated autocorrelated latent variables should be considered when constructing the correlation matrix. Default uses all the estimated parameters.}

\item{burning}{Logical. Whether the burning iterations should be include (\code{TRUE}) or not (\code{FALSE}).}
}
\value{
An object of class \code{corRandomEff}. This object is an array of four dimensions. The correlation between two species (first and second dimension) can be found for a particular iteration (third dimension) associated to a specific random effect.
}
\description{
Construct a species by species covariance (or correlation) matrix from the parameters of the latent variables (\code{paramLatent}). If multiple sets of latent variables were estimated, this function will calculate as many species by species covariance (or correlation) matrices as the number of sets of latent variables estimated in the \code{hmsc} object.
}
\details{
The output of this function is an array.
}
\examples{

#==================
### Simulating data
#==================
desc <- matrix(1, nrow = 50, ncol = 1)
random1 <- as.factor(1:50)
random2 <- as.factor(rep(letters[1:2], each = 25))
randEff <- data.frame(rand1 = random1, rand2 = random2)
nspecies <- 10

commRandEff2 <- communitySimul(X = desc, Random = randEff, nsp = nspecies)

#=================================
### Formatting data and parameters
#=================================
formdata <- as.HMSCdata(Y = commRandEff2$data$Y, X = desc, Random = randEff, 
						   interceptX = FALSE)

#==============
### Build model
#==============
modelRandEff2 <- hmsc(formdata, niter = 200, nburn = 100, thin = 1, 
						  verbose = FALSE)

#===============================
### Construct correlation matrix
#===============================
corRes <- corRandomEff(modelRandEff2)

#=================================
### Draw chord diagram with corRes
#=================================
library(circlize)

chordDiagram(corRes[, , 1, 1], symmetric = TRUE)

}
\seealso{
\code{\link{hmsc}}
}
\author{
F. Guillaume Blanchet
}
\keyword{IO}
